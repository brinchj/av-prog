In this section we discuss the convertion from the abstract syntax
tree generated by our SEL parser (Section \ref{parser}) to 2D code.
The problem consisst of three parts:
\begin{enumerate}
\item convertion from a SEL AST to a 2D specific AST
\item convertion from 2D AST to an abstract 2D layout
\item generation of the 2D layout
\end{enumerate}

\paragraph{Problems faced}
\label{compiler:problems}
\fixme{we had problems}

\paragraph{Layout}
\label{compiler:layout}
The main challenge of writing a compiler from the SEL to the 2D
language, was making a layout system that would output a valid 2D program.

\paragraph{Placement of wires}
\label{compiler:placement}
\fixme{Introduce our representation of 2d inside Haskell}

\paragraph{Modules}
\label{compiler:modules}
In order to cut down on the needed work, we decided to encapsulate
many of our functions in predefined modules. An example of this could
be the multiplication operator which we attempted to write manually,
both to get a sense of how 2D worked, as well as optimizing our use of
time until the layout system was up and running. Even though we had
already specified much of the logic needed for unary multiplication,
the construction was not straightforward. We found the biggetst
problem to be flow-control, as this required many wires, even for
small cases, which made the program much harder to write and modify.

We therefore abondoned this approch, even for basic features of our
language, and instead began to use our layouter to create the needed
modules.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "master"
%%% End:
