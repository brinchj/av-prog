% Conrete syntax for O'Cult

%% Natural numbers, consts are indexed by these
nat : type.
z : nat.
s : nat -> nat.

bool : type.
true : bool.
false : bool.

nat_lt : nat -> nat -> bool -> type.
%mode nat_lt +N1 +N2 -B.
- : nat_lt z (s _) true.
- : nat_lt z z false.
- : nat_lt (s K) (s M) B
     <- nat_lt K M B.
- : nat_lt (s _) z false.
%worlds () (nat_lt _ _ _).
%total N (nat_lt N _ _).

nat_plus : nat -> nat -> nat -> type.
%mode nat_plus +N1 +N2 -N3.
- : nat_plus z K K.
- : nat_plus (s K) L (s K')
     <- nat_plus K L K'.
%worlds () (nat_plus _ _ _).
%total N (nat_plus N _ _).


%% Terms, do we need them?
tm : type.
const : nat -> tm.
app : tm -> tm -> tm.

tm_eq : tm -> tm -> type.
%mode tm_eq +T -U.
tm_eq_refl : tm_eq T T.
%worlds () (tm_eq _ _).
%total T (tm_eq T _).

%% Patterns
pat : type.
pconst : nat -> pat.
papp : pat -> pat -> pat.
pvar : nat -> pat. %% Consider HOAS'ing this

%% Programs are rule lists.
program : type.
rule_list_nil : program.
rule_list_cons : pat -> pat -> program -> program.

%% Rules can be well-formed
wellformed : pat -> pat -> type.

ctx : type.
ctx_nil : ctx.
ctx_bind : nat -> tm -> ctx -> ctx.

ctx_option : type.
ctx_opt_none : ctx_option.
ctx_opt_some : tm -> ctx_option.

ctx_lookup : nat -> ctx -> ctx_option -> type.
- : ctx_lookup _ ctx_nil ctx_opt_none.
- : ctx_lookup Z (ctx_bind Z T _) (ctx_opt_some T).
- : ctx_lookup Z (ctx_bind _ _ R) R'
     <- ctx_lookup Z R R'.

pa_subst : ctx -> pat -> tm -> type.
- : pa_subst CTX (pconst K) (const K).
- : pa_subst CTX (pvar N) T
     <- ctx_lookup N CTX (ctx_opt_some T).
- : pa_subst CTX (papp P1 P2) (app P1' P2')
     <- pa_subst CTX P1 P1'
     <- pa_subst CTX P2 P2'.

ctx_option : type.
ctx_option_none : ctx_option.
ctx_option_some : ctx -> ctx_option.

%% Unification of bindings
unify : ctx -> ctx -> type.
- : unify ctx_nil _.
- : unify (ctx_bind K TM _) CTX2
     <- ctx_lookup K CTX2 ctx_opt_none.
- : unify (ctx_bind K TM _) CTX2
     <- ctx_lookup K CTX2 (ctx_opt_some TM')
     <- tm_eq TM TM'.

ctx_match_option : type.
ctx_match_none : ctx_match_option.
ctx_match_some : ctx -> ctx_match_option.

unify_option : ctx_match_option -> ctx_match_option -> type.
- : unify_option (ctx_match_some CTX1) (ctx_match_some CTX2)
     <- unify CTX1 CTX2.

%% Run union TODO TODO
ctx_union : ctx -> ctx -> ctx -> type.
- : ctx_union ctx_nil C C.
- : ctx_union (ctx_bind K T R) C C'
     <- ctx_lookup K C ctx_opt_none
     <- ctx_union R C C'.
- : ctx_union (ctx_bind K T R) C (ctx_bind K T C')
     <- ctx_lookup K C (ctx_opt_some _)
     <- ctx_union R C C'.

%% Matchings
match : ctx -> pat -> tm -> ctx_match_option -> type.
- : match CTX (pconst K) (const K) (ctx_match_some CTX).
- : match CTX (pconst K) (const M) ctx_match_none.
- : match CTX (pvar K) TM (ctx_match_some (ctx_bind K TM CTX)).
- : match CTX (papp A B) (app TA TB) (ctx_match_some CTXU)
     <- match CTX A TA (ctx_match_some CTXA)
     <- match CTX B TB (ctx_match_some CTXB)
     <- unify CTXA CTXB
     <- ctx_union CTXA CTX CTX'
     <- ctx_union CTXB CTX' CTXU.
- : match CTX (papp A B) (app TA TB) ctx_match_none
     <- match CTX A TA ctx_match_none.
- : match CTX (papp A B) (app TA TB) ctx_match_none
     <- match CTX B TB ctx_match_none.

%query 1 1 (match ctx_nil (pconst K) (const K) (ctx_match_some ctx_nil)).
%query 1 1 (match ctx_nil (pconst z) (const (s z)) ctx_match_none).
test_term1 = (app (const Z) (const Y)).
%query 1 1 (match CTX (pvar K) test_term1 (ctx_match_some (ctx_bind K test_term1 CTX))).

%% This one is evil. It must not match the CURRENT RULE but may match all the others
subterm_match_count : pat -> tm -> nat -> type.
- : subterm_match_count P T (s z)
     <- match ctx_nil P T (ctx_match_some _).
- : subterm_match_count P (const K) z
     <- match ctx_nil P (const K) ctx_match_none.
- : subterm_match_count P (app T1 T2) K
     <- subterm_match_count P T1 Z1
     <- subterm_match_count P T2 Z2
     <- nat_plus Z1 Z2 K.

%% Advise, which is really evaluation
advise :  program -> program -> tm -> tm -> type.
- : advise PRG rule_list_nil T T.
- : advise PRG (rule_list_cons P1 P2 L) T T'
     <- match ctx_nil P1 T (ctx_match_some CTX')
     <- pa_subst CTX P2 T'.
- : advise PRG (rule_list_cons (papp P1 P2) PT _) (app T1 T2) T'
     <- subterm_match_count P1 T1 z
     <- subterm_match_count P2 T2 z
     <- advise PRG L (app T1 T2) T'.
- : advise PRG (rule_list_cons (papp P1 P2) PT _) (app T1 T2) T'
     <- subterm_match_count P1 T1 K
     <- subterm_match_count P2 T2 K
     <- advise PRG L T T'.
- : advise PRG (rule_list_cons (papp P1 P2) PT _) (app T1 T2) T'
     <- subterm_match_count P1 T1 z
     <- subterm_match_count P2 T2 (s K)
     <- advise PRG (rule_list_cons (papp P1 P2) PT rule_list_nil) T1 T'.
- : advise PRG (rule_list_cons (papp P1 P2) PT _) (app T1 T2) T'
     <- subterm_match_count P1 T1 (s K)
     <- subterm_match_count P2 T2 z
     <- advise PRG (rule_list_cons (papp P1 P2) PT rule_list_nil) T2 T'.
- : advise PRG (rule_list_cons (papp P1 P2) PT _) (app T1 T2) T'
     <- subterm_match_count P1 T1 Z1
     <- subterm_match_count P2 T2 Z2
     <- nat_lt Z1 Z2 true
     <- advise PRG (rule_list_cons (papp P1 P2) PT rule_list_nil) T2 T'.
- : advise PRG (rule_list_cons (papp P1 P2) PT _) (app T1 T2) T'
     <- subterm_match_count P1 T1 Z1
     <- subterm_match_count P2 T2 Z2
     <- nat_lt Z2 Z1 true
     <- advise PRG (rule_list_cons (papp P1 P2) PT rule_list_nil) T1 T'.

%% #########################################
%% ##### Translation from Occult to 2d #####
%% #########################################

transl_nat : nat -> exp -> type.
%mode transl_nat +K -E.
transl_nat_z : transl_nat z (inl unit).
transl_nat_s : transl_nat (s K) (inr K')
		<- transl_nat K K'.

transl_tm : tm -> exp -> type.
%mode transl_tm +T -E.
- : transl_tm (const K) (inr K')
     <- transl_nat K K'.
- : transl_tm (app T1 T2) (inl (pair T1' T2'))
     <- transl_tm T1 T1'
     <- transl_tm T2 T2'.

transl_pat : pat -> exp -> type.
%mode transl_pat +P -E.
- : transl_pat (pconst K) (inr (inl K'))
     <- transl_nat K K'.
- : transl_pat (pvar K) (inr (inr K'))
     <- transl_nat K K'.
- : transl_pat (papp P1 P2) (inl (pair P1' P2'))
     <- transl_pat P1 P1'
     <- transl_pat P2 P2'.

transl_rule : pat -> pat -> exp -> type.
%mode transl_rule +P1 +P2 -E.
- : transl_rule T1 T2 (pair T1' T2')
     <- transl_pat T1 T1'
     <- transl_pat T2 T2'.

