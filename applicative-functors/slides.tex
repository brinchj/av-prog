\documentclass[18pt]{beamer}
\usepackage[T1]{fontenc}
\usepackage[protrusion=true,expansion=true]{microtype}
%usepackage[minionint,mathlf]{MinionPro}
%\usepackage[sc,osf]{mathpazo}
\usepackage{listings}
\usepackage{diagrams}
%\renewcommand{\sfdefault}{Myriad-LF}

\definecolor{gray_ulisses}{gray}{0.55}
\definecolor{castanho_ulisses}{rgb}{0.71,0.33,0.14}
\definecolor{preto_ulisses}{rgb}{0.41,0.20,0.04}
\definecolor{green_ulises}{rgb}{0.2,0.75,0}

\lstdefinelanguage{HaskellUlisses} {
	basicstyle=\ttfamily,
	sensitive=true,
	morecomment=[l][\color{gray_ulisses}\ttfamily]{--},
	morecomment=[s][\color{gray_ulisses}\ttfamily]{\{-}{-\}},
	morestring=[b]",
	stringstyle=\color{red},
	showstringspaces=false,
	%numberstyle=,
	numberblanklines=true,
	showspaces=false,
	breaklines=true,
	showtabs=false,
	emph=
	{[1]
		FilePath,IOError,abs,acos,acosh,all,and,any,appendFile,approxRational,asTypeOn,
		asinh,atan,atan2,atanh,basicIORun,break,catch,ceiling,chr,compare,concat,concatMap,
		const,cos,cosh,curry,cycle,decodeFloat,denominator,digitToInt,div,divMod,drop,
		dropWhile,either,elem,encodeFloat,enumFrom,enumFromThen,enumFromThenTo,enumFromTo,
		error,even,exp,exponent,fail,filter,flip,floatDigits,floatRadix,floatRange,floor,
		fmap,foldl,foldl1,foldr,foldr1,fromDouble,fromEnum,fromInt,fromInteger,fromIntegral,
		fromRational,fst,gcd,getChar,getContents,getLine,head,id,inRange,index,init,intToDigit,
		interact,ioError,isAlpha,isAlphaNum,isAscii,isControl,isDenormalized,isDigit,isHexDigit,
		isIEEE,isInfinite,isLower,isNaN,isNegativeZero,isOctDigit,isPrint,isSpace,isUpper,iterate,
		last,lcm,length,lex,lexDigits,lexLitChar,lines,log,logBase,lookup,map,mapM,mapM_,max,
		maxBound,maximum,maybe,min,minBound,minimum,mod,negate,not,notElem,null,numerator,odd,
		or,ord,otherwise,pi,pred,primExitWith,print,product,properFraction,putChar,putStr,putStrLn,quot,
		quotRem,range,rangeSize,read,readDec,readFile,readFloat,readHex,readIO,readInt,readList,readLitChar,
		readLn,readOct,readParen,readSigned,reads,readsPrec,realToFrac,recip,rem,repeat,replicate,return,
		reverse,round,scaleFloat,scanl,scanl1,scanr,scanr1,seq,sequence,sequence_,show,showChar,showInt,
		showList,showLitChar,showParen,showSigned,showString,shows,showsPrec,significand,signum,sin,
		sinh,snd,span,splitAt,sqrt,subtract,succ,sum,tail,take,takeWhile,tan,tanh,threadToIOResult,toEnum,
		toInt,toInteger,toLower,toRational,toUpper,truncate,uncurry,undefined,unlines,until,unwords,unzip,
		unzip3,userError,words,writeFile,zip,zip3,zipWith,zipWith3,listArray,doParse
	},
	emphstyle={[1]\color{blue}},
	emph=
	{[2]
		Bool,Char,Double,Either,Float,IO,Integer,Int,Maybe,Ordering,Rational,Ratio,ReadS,ShowS,String,
		Word8,InPacket
	},
	emphstyle={[2]\color{castanho_ulisses}},
	emph=
	{[3]
		case,class,data,deriving,do,else,if,import,in,infixl,infixr,instance,let,
		module,of,primitive,then,type,where
	},
	emphstyle={[3]\color{preto_ulisses}\textbf},
	emph=
	{[4]
		quot,rem,div,mod,elem,notElem,seq
	},
	emphstyle={[4]\color{castanho_ulisses}\textbf},
	emph=
	{[5]
		EQ,False,GT,Just,LT,Left,Nothing,Right,True,Show,Eq,Ord,Num
	},
	emphstyle={[5]\color{preto_ulisses}\textbf}
}

\lstnewenvironment{code}
{\textbf{Haskell Code} \hspace{1cm} \hrulefill \lstset{language=HaskellUlisses}}{}

\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{semantic}

\usetheme{default}
\usefonttheme{professionalfonts}
%\usefonttheme[]{structuresmallcapsserif}
\begin{document}

\frame{
  \begin{center}
    Applicative programming\\
    with effects\\
  \end{center}
}

\begin{frame}[fragile]
  The Functor definition\\

  \begin{code}
    class Functor f where
      fmap :: (a -> b) -> f a -> f b
  \end{code}

\end{frame}

\begin{frame}[fragile]
  The (standard) instance\\
  \begin{code}
    class Functor [] where
      fmap f [] = []
      fmap f (x : xs) = f x : (fmap f xs)
  \end{code}
\end{frame}

\begin{frame}[fragile]
What we have without Applicative Functors:\\

\begin{code}
data Exp v = Var v
           | Val Int
           | Add (Exp v) (Exp v)

eval :: Exp v -> Env v -> Int
eval (Var x) g = fetch x g
eval (Val i) g = i
eval (Add p q) g = eval p g + eval q g
\end{code}
Not very pretty - nor general
\end{frame}

\begin{frame}[fragile]
We can do better:
\begin{code}
eval :: Exp v -> Env v -> Int
eval (Var x) = fetch x 
eval (Val i) = K i
eval (Add p q) = K (+) 'S' eval p 'S'eval q
\end{code}
where\\
\begin{code}
K :: a -> env -> a
K x \gamma = x
\end{code}
and\\
\begin{code}
S :: (env -> a -> b) -> (env -> a) -> (env -> b)
S ef es g = (ef g) (es g)
\end{code}
\end{frame}

\begin{frame}[fragile]
Better - not good, not general.
\end{frame}

\begin{frame}[fragile]

Rules:

\begin{description}
\item[Identity:] pure id $\circledast$ u = u
\item[Composition:] pure $( \bullet ) \circledast u \circledast v \circledast$ w =  u $\circledast (v \circledast$ w)
\item[Homomorphism:] pure f $\circledast$ pure x = pure (f x)
\item[Interchange:] u $\circledast$ x = pure ($\lambda f \rightarrow f x) \circledast u$
\end{description}
%Dollor sign
\end{frame}

\begin{frame}[fragile]
Canonical form:\\
pure $f \circledast u_1 \circledast \ldots \circledast u_n \equiv |[f u_1 \ldots u_n|]$\\
so in practice\\
\begin{code}
pure f 'star' u1 'star' ... 'star' un
\end{code}
\end{frame}

\begin{frame}[fragile]
Let's return to our start example - but first!\\
\begin{code}
instance Applicative ((->) env) where
pure x = \g -> x --K
ef 'star' ex = \g -> (ef g)(ex g) -- S
\end{code}

So now:
\begin{code}
eval :: Exp v -> Env v -> Int
eval (Var x) = fetch x
eval (Val i) = pure i
eval (Add p q) = pure (+) 'star'  (eval p) 'star' (eval q)
\end{code}
Much better.

\end{frame}

\begin{frame}

\end{frame}


% \frame{
%   \begin{center}
%     \large{Goals:}\\
%     \begin{itemize}
%     \item Simplicity
%     \item It is in the details!
%     \item Understanding the domain.
%     \end{itemize}
%   \end{center}
% }

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
